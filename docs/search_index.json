[["regex.html", "13 Regular expressions 13.1 Cleaning the district column 13.2 Detecting robberies in police reports 13.3 Extracting details from a list of names", " 13 Regular expressions In Web Scraping, we are often dealing with text data that has been collected from a website and may include information that is not directly accessible and usable in data analysis. We may be interested in detecting the occurrence of certain words or in extracting some information from the strings in our data. For these purposes we will use some functions from the core tidyverse package stringr. We will also use regular expressions, a powerful and flexible formal representation of characters we can use to select substrings by their content. This chapter will make use of some practical examples, introducing the basics of regular expressions and stringr. This can only be a starting point. If you want to further follow the road of Web Scraping, you most probably will have to further your knowledge on regular expressions at some point. A recommended next step would be the chapter on strings from “R for Data Science” by Wickham and Grolemund: https://r4ds.had.co.nz/strings.html, as well as the RStudio Cheat Sheet on stringr: https://raw.githubusercontent.com/rstudio/cheatsheets/master/strings.pdf. 13.1 Cleaning the district column library(tidyverse) load(&quot;reports.RData&quot;) The data on police reports we used contains the district a report refers to as a column which needs some cleaning to be usable. reports %&gt;% select(District) %&gt;% head(n = 10) ## # A tibble: 10 x 1 ## District ## &lt;chr&gt; ## 1 Ereignisort: Treptow-Köpenick ## 2 Ereignisort: Tempelhof-Schöneberg ## 3 Ereignisort: bezirksübergreifend ## 4 Ereignisort: bezirksübergreifend ## 5 Ereignisort: Tempelhof-Schöneberg ## 6 Ereignisort: Friedrichshain-Kreuzberg ## 7 Ereignisort: Steglitz-Zehlendorf ## 8 Ereignisort: Charlottenburg-Wilmersdorf ## 9 Ereignisort: Marzahn-Hellersdorf ## 10 Ereignisort: Charlottenburg-Wilmersdorf The first problem is, that each string begins with “Ereignisort:”. We may want to get rid of this substring, as it does not contain any useful information. With str_remove() we can remove substrings from a string. Like all stringr functions we will use here, str_remove() takes the string(s) to be applied to as its first argument, as well as the argument pattern = to specify a regular expression for the pattern that is to be matched and removed. In the code block below, all strings from District are passed through the pipe and \"Ereignisort: is removed. We’re using the most basic form of a regular expression here which is the exact matching of characters. In general, the complete regular expression is enclosed by \". reports$District %&gt;% str_remove(pattern = &quot;Ereignisort: &quot;) %&gt;% head(n = 10) ## [1] &quot;Treptow-Köpenick&quot; &quot;Tempelhof-Schöneberg&quot; ## [3] &quot;bezirksübergreifend&quot; &quot;bezirksübergreifend&quot; ## [5] &quot;Tempelhof-Schöneberg&quot; &quot;Friedrichshain-Kreuzberg&quot; ## [7] &quot;Steglitz-Zehlendorf&quot; &quot;Charlottenburg-Wilmersdorf&quot; ## [9] &quot;Marzahn-Hellersdorf&quot; &quot;Charlottenburg-Wilmersdorf&quot; Maybe we want to keep the substring but translate it to English. For this, we can use str_replace() which also matches a regular expression, but replaces it with a string specified in replacement =. Here, the pattern is shortened to \"Ereignisort\", as we want to keep the \": \". reports$District %&gt;% str_replace(pattern = &quot;Ereignisort&quot;, replacement = &quot;District&quot;) %&gt;% head(n = 10) ## [1] &quot;District: Treptow-Köpenick&quot; ## [2] &quot;District: Tempelhof-Schöneberg&quot; ## [3] &quot;District: bezirksübergreifend&quot; ## [4] &quot;District: bezirksübergreifend&quot; ## [5] &quot;District: Tempelhof-Schöneberg&quot; ## [6] &quot;District: Friedrichshain-Kreuzberg&quot; ## [7] &quot;District: Steglitz-Zehlendorf&quot; ## [8] &quot;District: Charlottenburg-Wilmersdorf&quot; ## [9] &quot;District: Marzahn-Hellersdorf&quot; ## [10] &quot;District: Charlottenburg-Wilmersdorf&quot; In the same way, we can replace the \": \" substring with a dash. reports$District %&gt;% str_replace(pattern = &quot;: &quot;, replacement = &quot;-&quot;) %&gt;% head(n = 10) ## [1] &quot;Ereignisort-Treptow-Köpenick&quot; ## [2] &quot;Ereignisort-Tempelhof-Schöneberg&quot; ## [3] &quot;Ereignisort-bezirksübergreifend&quot; ## [4] &quot;Ereignisort-bezirksübergreifend&quot; ## [5] &quot;Ereignisort-Tempelhof-Schöneberg&quot; ## [6] &quot;Ereignisort-Friedrichshain-Kreuzberg&quot; ## [7] &quot;Ereignisort-Steglitz-Zehlendorf&quot; ## [8] &quot;Ereignisort-Charlottenburg-Wilmersdorf&quot; ## [9] &quot;Ereignisort-Marzahn-Hellersdorf&quot; ## [10] &quot;Ereignisort-Charlottenburg-Wilmersdorf&quot; As seen in chapter 11, district names with two parts, are sometimes written with and sometimes without whitespace around the dash, as seen here: reports %&gt;% group_by(District) %&gt;% summarize(reports = n()) ## # A tibble: 22 x 2 ## District reports ## * &lt;chr&gt; &lt;int&gt; ## 1 Ereignisort: berlinweit 252 ## 2 Ereignisort: bezirksübergreifend 775 ## 3 Ereignisort: bundesweit 39 ## 4 Ereignisort: Charlottenburg - Wilmersdorf 580 ## 5 Ereignisort: Charlottenburg-Wilmersdorf 980 ## 6 Ereignisort: Friedrichshain - Kreuzberg 661 ## 7 Ereignisort: Friedrichshain-Kreuzberg 1170 ## 8 Ereignisort: Lichtenberg 890 ## 9 Ereignisort: Marzahn - Hellersdorf 253 ## 10 Ereignisort: Marzahn-Hellersdorf 560 ## # … with 12 more rows We can easily unify those names using str_replace and regular expressions. reports %&gt;% mutate(District = str_replace(District, pattern = &quot; - &quot;, replacement = &quot;-&quot;)) %&gt;% group_by(District) %&gt;% summarize(reports = n()) ## # A tibble: 16 x 2 ## District reports ## * &lt;chr&gt; &lt;int&gt; ## 1 Ereignisort: berlinweit 252 ## 2 Ereignisort: bezirksübergreifend 775 ## 3 Ereignisort: bundesweit 39 ## 4 Ereignisort: Charlottenburg-Wilmersdorf 1560 ## 5 Ereignisort: Friedrichshain-Kreuzberg 1831 ## 6 Ereignisort: Lichtenberg 890 ## 7 Ereignisort: Marzahn-Hellersdorf 813 ## 8 Ereignisort: Mitte 2557 ## 9 Ereignisort: Neukölln 1468 ## 10 Ereignisort: Pankow 1245 ## 11 Ereignisort: Reinickendorf 898 ## 12 Ereignisort: Spandau 835 ## 13 Ereignisort: Steglitz-Zehlendorf 790 ## 14 Ereignisort: Tempelhof-Schöneberg 1345 ## 15 Ereignisort: Treptow-Köpenick 1014 ## 16 &lt;NA&gt; 395 If all we want is to remove the whitespace, unifying the names in the process, we can use str_remove() and the regular expression \"\\\\s\", being a shortcut for selecting all kinds of whitespace. At this point we have to talk about escape characters. Some characters used in regular expressions have a special meaning, e.g. \".\", \"?\" or \"*\". If we just write one of those characters in a regular expression, R will not interpret is as a literal character but by its special meaning. \".\" used in a regular expression for example, stands for any character. If we want to match a literal . in a string though, we have to escape the dot by using the escape character \\ or actually two, telling R to take the next character literally. So to match a dot, we write \"\\\\.\". If this seems confusing and needlessly complicated, save your rage for when you find out what you have to write to match one literal backslash in a string: \\\\\\\\. Some commentary on this: https://xkcd.com/1638/ Escape characters are hard to understand when starting out using regular expressions, but for now it is enough to know that some characters have to be escaped and that you find a full list of those in the cheat sheet linked above. In a similar way, we have to use two escape characters in \"\\\\s\" to make R interpret it not as an “s” but as the shortcut for whitespace characters we want to use: reports %&gt;% mutate(District = str_remove(District, pattern = &quot;\\\\s&quot;)) %&gt;% group_by(District) %&gt;% summarize(reports = n()) ## # A tibble: 22 x 2 ## District reports ## * &lt;chr&gt; &lt;int&gt; ## 1 Ereignisort:berlinweit 252 ## 2 Ereignisort:bezirksübergreifend 775 ## 3 Ereignisort:bundesweit 39 ## 4 Ereignisort:Charlottenburg - Wilmersdorf 580 ## 5 Ereignisort:Charlottenburg-Wilmersdorf 980 ## 6 Ereignisort:Friedrichshain - Kreuzberg 661 ## 7 Ereignisort:Friedrichshain-Kreuzberg 1170 ## 8 Ereignisort:Lichtenberg 890 ## 9 Ereignisort:Marzahn - Hellersdorf 253 ## 10 Ereignisort:Marzahn-Hellersdorf 560 ## # … with 12 more rows This did not work as expected. The whitespace following the \":\" was removed, but not the whitespace around the dashes. This is the case, because most of the stringr functions stop after they found the first match for the pattern in a string. But there are versions of the functions that do not stop after their first match, ending in _all: e.g. str_replace_all(). So if we use str_remove_all() in our code, all occurrences of whitespace will be removed. reports %&gt;% mutate(District = str_remove_all(District, pattern = &quot;\\\\s&quot;)) %&gt;% group_by(District) %&gt;% summarize(reports = n()) ## # A tibble: 16 x 2 ## District reports ## * &lt;chr&gt; &lt;int&gt; ## 1 Ereignisort:berlinweit 252 ## 2 Ereignisort:bezirksübergreifend 775 ## 3 Ereignisort:bundesweit 39 ## 4 Ereignisort:Charlottenburg-Wilmersdorf 1560 ## 5 Ereignisort:Friedrichshain-Kreuzberg 1831 ## 6 Ereignisort:Lichtenberg 890 ## 7 Ereignisort:Marzahn-Hellersdorf 813 ## 8 Ereignisort:Mitte 2557 ## 9 Ereignisort:Neukölln 1468 ## 10 Ereignisort:Pankow 1245 ## 11 Ereignisort:Reinickendorf 898 ## 12 Ereignisort:Spandau 835 ## 13 Ereignisort:Steglitz-Zehlendorf 790 ## 14 Ereignisort:Tempelhof-Schöneberg 1345 ## 15 Ereignisort:Treptow-Köpenick 1014 ## 16 &lt;NA&gt; 395 13.2 Detecting robberies in police reports When collecting the data on police reports, we also scraped the short description of the report’s contents, but did no analysis on these in chapters 11 &amp; 12. We could try to categorize the texts into types of crimes using regular expressions. Doing this properly, would require a lot of planning. We would have to decide which categories of crimes we want to extract and construct flexible regular expressions for all of these. Please understand the following only as a first outline for how to approach such a project. Let us focus solely on robberies. As a first step, we detect all strings that contain the term “raub” in some form. str_detect() determines whether a pattern was found in a string, returning TRUEor FALSE. We can then count the number of strings for which the result is TRUE– remember TRUEis equal to \\(1\\), FALSE equal to \\(0\\) – using sum(). reports$Report %&gt;% str_detect(pattern = &quot;raub&quot;) %&gt;% sum() ## [1] 424 But what if a text begins with “Raub”. In this case the “R” will be upper case. Pattern matching is case sensitive and this means that “Raub” is not equal to “raub”. If we want both ways of writing the term to be counted as equal, we have to write a regular expression that allows for either an upper or lower case “r” as the first character. For this we can define a class which contains both characters enclosed by []. \"[Rr]aub\" means that we want to find either an “R” or an “r” as the first character and “aub” after this; only one of the characters from the class is matched. reports$Report %&gt;% str_detect(pattern = &quot;[Rr]aub&quot;) %&gt;% sum() ## [1] 932 If we also want to detect terms like “Räuber” or “räuberische”, we have to allow for an “ä” instead of the “a” as the second character by defining a class for the second position in the term: reports$Report %&gt;% str_detect(pattern = &quot;[rR][aä]ub&quot;) %&gt;% sum() ## [1] 1214 Let us have a look at some of the strings which returned a TRUE match, using str_detect() in subsetting; telling R we want to see only lines from reports for which the pattern could be found, and only the first \\(10\\) of these. reports[str_detect(reports$Report, pattern = &quot;[Rr][aä]ub&quot;), ] %&gt;% head(n=10) ## # A tibble: 10 x 3 ## Date Report District ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 18.06.2021 1… &quot;Raub im Hausflur&quot; Ereignisort: Charlott… ## 2 18.06.2021 1… &quot;Mit dem Rettungshubschrauber ins Krank… Ereignisort: Spandau ## 3 12.06.2021 1… &quot;Drei Raubüberfälle in 30 Minuten - Tat… Ereignisort: Charlott… ## 4 09.06.2021 1… &quot;Öffentlichkeitsfahndung nach schwerem … Ereignisort: Mitte ## 5 05.06.2021 1… &quot;Supermarkt überfallen und beraubt - An… Ereignisort: Pankow ## 6 30.05.2021 1… &quot;Mann geschlagen, getreten und beraubt&quot; Ereignisort: Mitte ## 7 28.05.2021 0… &quot;Jugendlicher Räuber mit Besen vertrieb… Ereignisort: Tempelho… ## 8 27.05.2021 1… &quot;Nach Raubüberfall auf Geldboten – zwei… Ereignisort: Neukölln ## 9 07.05.2021 1… &quot;Goldring geraubt - Festnahme&quot; Ereignisort: Spandau ## 10 05.05.2021 1… &quot;Ladenbesitzer bei Raubüberfall mit Mes… Ereignisort: Mitte This looks good at first sight, but why was a report on a motorcycle accident included? Because the word “Rettungshubschrauber” also has “raub” in it. You see, how reliably detecting a simple string such as “raub” gets complicated very quickly. At this point, we would have to put in the hours and define a list of phrases referring to robberies that we actually want to select while constructing regular expressions that select those phrases and only those. This is beyond the scope of this introductory example, but as a first approximation we could say that we want to find all instances in which the words begin with a capital “R”, as in “Raub” or “Räuber”, or where “aub” and “äub” are prefixed with “ge”, “be” or “zu”, as in “geraubt”, “beraubt”, or “auszurauben”. To achieve this, the regular expression has to allow for four optional substrings, using grouping and the “OR” operator |. Groups are defined by enclosing several expressions in parentheses. While groups have advanced functionality, for now you can interpret them like parentheses in mathematics. The enclosed expression is evaluated first and as a whole. If one of the prefixes, connected by |, is found in a string and is then followed up by either “a” or “ä” and “ub” after this, the pattern is matched. reports[str_detect(reports$Report, pattern = &quot;(R|ger|ber|zur)[aä]ub&quot;), ] %&gt;% head(n=10) ## # A tibble: 10 x 3 ## Date Report District ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 18.06.2021 1… Raub im Hausflur Ereignisort: Charlotte… ## 2 12.06.2021 1… Drei Raubüberfälle in 30 Minuten - Tat… Ereignisort: Charlotte… ## 3 09.06.2021 1… Öffentlichkeitsfahndung nach schwerem … Ereignisort: Mitte ## 4 05.06.2021 1… Supermarkt überfallen und beraubt - An… Ereignisort: Pankow ## 5 30.05.2021 1… Mann geschlagen, getreten und beraubt Ereignisort: Mitte ## 6 28.05.2021 0… Jugendlicher Räuber mit Besen vertrieb… Ereignisort: Tempelhof… ## 7 27.05.2021 1… Nach Raubüberfall auf Geldboten – zwei… Ereignisort: Neukölln ## 8 07.05.2021 1… Goldring geraubt - Festnahme Ereignisort: Spandau ## 9 05.05.2021 1… Ladenbesitzer bei Raubüberfall mit Mes… Ereignisort: Mitte ## 10 04.05.2021 1… Ausgeraubt und fremdenfeindlich beleid… Ereignisort: Treptow-K… There are other words in the German language that are used to describe the concept of robberies. Adding all of them and the several individual pre- and/or suffixes that have to be taken into account to reliably select the terms we want to select and none of those we do not want to select, is beyond the scope of this example. But we can at least add one further word to the regular expression. Using the | operator we extend the regular expression to also detect “dieb” with a upper or lower case “d”. The expression now selects all ways of writing “raub” and “dieb” we allowed for. reports[str_detect(reports$Report, pattern = &quot;(R|ger|ber|zur)[aä]ub|[Dd]ieb&quot;), ] %&gt;% head(n=10) ## # A tibble: 10 x 3 ## Date Report District ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 18.06.2021 1… Raub im Hausflur Ereignisort: Charlotte… ## 2 12.06.2021 1… Drei Raubüberfälle in 30 Minuten - Tat… Ereignisort: Charlotte… ## 3 09.06.2021 1… Öffentlichkeitsfahndung nach schwerem … Ereignisort: Mitte ## 4 05.06.2021 1… Supermarkt überfallen und beraubt - An… Ereignisort: Pankow ## 5 03.06.2021 1… Mann nach Fahrzeugdiebstahl festgenomm… Ereignisort: Reinicken… ## 6 30.05.2021 1… Mann geschlagen, getreten und beraubt Ereignisort: Mitte ## 7 30.05.2021 1… Festnahme nach Diebstahl aus Auto Ereignisort: Charlotte… ## 8 28.05.2021 0… Jugendlicher Räuber mit Besen vertrieb… Ereignisort: Tempelhof… ## 9 27.05.2021 1… Nach Raubüberfall auf Geldboten – zwei… Ereignisort: Neukölln ## 10 20.05.2021 1… Festnahme nach Taschendiebstahl Ereignisort: Friedrich… Now that we have a constructed a regular expression that can detect reports that are related to robberies – at least approximately – we can compute their number and relative proportion. Remember, we are dealing with a logical vector of ones and zeros; sum() counts all ones and thus returns the absolute number of reports and mean() divides the number of ones by the number of all reports, thus returning the relative proportion. reports$Report %&gt;% str_detect(pattern = &quot;(R|ger|ber|zur)[aä]ub|[Dd]ieb&quot;) %&gt;% sum() ## [1] 1617 reports$Report %&gt;% str_detect(pattern = &quot;(R|ger|ber|zur)[aä]ub|[Dd]ieb&quot;) %&gt;% mean() ## [1] 0.09678578 13.3 Extracting details from a list of names The website https://www.bundeswahlleiter.de/bundestagswahlen/2017/gewaehlte/bund-99/ lists all German members of parliament in tables, with the first column holding the full names and academic degrees in one character string. A common application of regular expressions in the context of web scraping is to extract substrings of interest from such text. We will first scrape the data. The members of parliament are divided into 26 subpages, one for each first letter of their last names, in the form “a.html”, “b.html” and so on. We construct links to all these pages using the base R object letters, a character vector conveniently containing of all 26 letters of the alphabet in lower case. We then read the links and extract the table cells containing the names into a character vector, which is then transformed into a tibble. library(rvest) website &lt;- &quot;https://www.bundeswahlleiter.de/bundestagswahlen/2017/gewaehlte/bund-99/&quot; links &lt;- str_c(website, letters, &quot;.html&quot;) pages &lt;- links %&gt;% map(~ { Sys.sleep(2) read_html(.x) }) names &lt;- pages %&gt;% map(html_nodes, css = &quot;th[scope=&#39;row&#39;]&quot;) %&gt;% map(html_text, trim = TRUE) %&gt;% unlist() names_tbl &lt;- tibble( full_name = names ) Our goal is to extract the academic degree from strings of full names. We first need to understand the pattern of how degrees are listed in those strings. Let us look at an example: names_tbl[65:69, ] ## # A tibble: 5 x 1 ## full_name ## &lt;chr&gt; ## 1 Dr. Brantner, Franziska ## 2 Dr. Brauksiepe, Ralf ## 3 Braun, Jürgen ## 4 Prof. Dr. Braun, Helge Reinhold ## 5 Breher, Silvia If the members of parliament carry an academic degree, the string begins with it. The abbreviated titles always end in a dot. Based on this, we can start constructing a regular expression that will be used to detect and extract academic degrees. We know that if there is a degree, they are listed at the beginning of the string. We can refer to the beginning and ending of a string by using an anchor. Writing ^ in a regular expression refers to the beginning of a string, $ to the ending. [:alpha:] is a predefined class that includes all upper and lower case letters, which we will use to refer to letters in general. \"^[:alpha:]\" will select one upper or lower case letter that is the first character in a string. We do not want to select only one character but complete titles. For this we need to use quantifiers. These are used to define how often elements of an expression are allowed or required to repeat. If we know the exact number of repetitions, we can set this number contained in {} after an element. \"^[:alpha:]{2}\" will select the first two letters in each string; always exactly two. The actual titles vary in the number of letters they contain. To allow for variation in the number of repetitions we use the quantifiers ?, * and +. ? stands for zero or one, * for zero or multiple and + for one or multiple repetitions; multiple meaning \\(n &gt;=1\\). \"^[:alpha:]+\" will select the word a string begins with. [:alpha:] does not contain any whitespace characters. Because of this, the regular expression will begin selecting letters at the beginning of a string until it “hits” whitespace. For members of parliament without a degree, this would select their last name. To make sure we only select titles, we can make use of the fact that all titles in this data end with a “.”. As the dot is a special character – standing for any character – we have to escape it by using two backslashes. The regular expression \"^[:alpha:]+\\\\.\" selects all words at the beginning of a string that end with a dot. We use it in the function str_extract() which will extract the substring that is specified by the regular expression if it could be found in the string. We use the function inside of mutate() to assign the extracted degrees into a new column. To get an overview of the result, we group the data by this new column and count the occurrences per group. names_tbl %&gt;% mutate(academic = str_extract(full_name, pattern = &quot;^[:alpha:]+\\\\.&quot;)) %&gt;% group_by(academic) %&gt;% summarise(n()) ## # A tibble: 3 x 2 ## academic `n()` ## * &lt;chr&gt; &lt;int&gt; ## 1 Dr. 119 ## 2 Prof. 11 ## 3 &lt;NA&gt; 579 We successfully identified a high percentage of doctors, as well as some professors. In some cases there actually are multiple titles – i.e. “Prof. Dr.”. We can extend the expression to allow for this as well. If there are two or more components to a title, they are separated by whitespace; which we can refer to using \\\\s. After the whitespace there will be another word ending in a dot. Thus we can reuse the first part of the expression, without the anchor: \"\\\\s[:alpha:]+\\\\.\". Some members of parliament have one title, others have mutliple. We have to allow for this as well. A quantifier that follows a part of an expression grouped by enclosure in parentheses will refer to the complete group. \"(\\\\s[:alpha:]+\\\\.)*\" allows there to be no additional title or multiple ones. Appending this to the regular expression used in the code above, allows us to select and extract one or more titles. names_tbl %&gt;% mutate(academic = str_extract(full_name, pattern = &quot;^[:alpha:]+\\\\.(\\\\s[:alpha:]+\\\\.)*&quot;)) %&gt;% group_by(academic) %&gt;% summarise(n()) ## # A tibble: 5 x 2 ## academic `n()` ## * &lt;chr&gt; &lt;int&gt; ## 1 Dr. 118 ## 2 Dr. h. c. 1 ## 3 Prof. Dr. 10 ## 4 Prof. h. c. Dr. 1 ## 5 &lt;NA&gt; 579 "]]
